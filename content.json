{"pages":[{},{}],"posts":[{"title":"Redis和数据库的缓存一致性问题","date":"2023-05-31T14:17:13.000Z","path":"2023/05/31/Redis和数据库的缓存一致性问题/","text":"Redis和数据库的如何保证缓存一致性？Redis和数据库的缓存一致性问题是一个常见的挑战，这个问题涉及到如何确保缓存数据与数据库数据的一致性。在实际应用中，如果缓存数据与数据库数据不一致，可能会导致严重的后果，例如数据丢失、数据不一致等问题。因此，解决这个问题是非常重要的。 在本文中，我们将讨论Redis和数据库的缓存一致性问题，并提供一些解决方案，以确保缓存数据与数据库数据的一致性。 1. 什么是Redis和数据库的缓存一致性问题？Redis缓存一致性问题指的是当应用程序使用Redis作为缓存时，缓存中的数据与数据库中的数据不一致的情况。 Redis是一种基于内存的键值存储系统，它可以用来缓存数据以提高应用程序的性能。在实际应用中，我们通常会使用Redis来缓存一些经常使用的数据，例如用户信息、商品信息等。 然而，在使用Redis缓存数据时，我们需要考虑到缓存数据与数据库数据的一致性问题。因为Redis是基于内存的，所以如果缓存数据与数据库数据不一致，可能会导致数据丢失、数据不一致等问题。 例如，假设我们有一个在线商店，我们将商品信息存储在数据库中，并使用Redis作为缓存。当用户查看商品时，我们首先检查Redis缓存中是否存在该商品信息。如果存在，则返回缓存数据。否则，我们从数据库中检索数据，并将其存储在Redis缓存中以供以后使用。 现在假设我们更改了某个商品的价格，并更新了数据库中的数据。但是，由于Redis缓存中仍然存在旧的商品信息，因此当用户再次查看该商品时，他们将看到旧的价格。这会导致用户的困惑和不满，并对商店的声誉造成影响。 因此，我们必须确保缓存中的数据始终与数据库中的数据保持一致。 问题的关键：一份数据同时保存在数据库和Redis中，当数据发生变化时，需要同时去更新数据库和Redis。由于更新操作是有先后顺序的，它并不像MySQL中多表事务操作可以同时满足ACID的特性，所以就会存在数据一致性问题。 2. 可供选择的几种方案为了解决Redis和数据库的缓存一致性问题，我们可以采用以下几种解决方案： 先更新数据库，再更新缓存 先删除缓存，再更新数据库 2.1. 先更新数据库，再更新缓存理想情况下：更新数据库成功，更新缓存成功 —— 不会存在一致性问题 极端情况下： 更新数据库成功，更新缓存失败 —— 存在一致性问题（缓存中的数据为脏数据） 解决方案：对更新缓存操作进行异常捕获，如果更新缓存失败，对缓存进行重试删除，不能让脏数据在缓存中持续的时间太长。ps：如果重试一定次数之后仍然失败，触发告警，人工介入。 2.2. 先删除缓存，再更新数据库 因为删除缓存操作和更新数据库这两个操作不是原子性操作，在这个过程中是否有其他的线程来访问会决定会不会存在一致性问题。 理想情况下：删除缓存和更新数据库期间，没有其他线程来访问 —— 不会存在一致性问题 极端情况下： 删除缓存和更新数据库期间，有其他线程来访问 —— 存在一致性问题 解决方案：在更新数据库成功，再次删除缓存，避免缓存中已被更新成脏数据。ps：删除操作还是采用重试删除（如果重试一定次数之后仍然失败，触发告警，人工介入） 双写策略是指在更新数据库时同时更新Redis缓存和数据库。这确保了数据始终保持一致，并提高了系统可用性。 例如，在上面的示例中，我们可以在更新商品信息时同时更新Redis缓存和数据库。这将确保下一个请求从Redis缓存中检索最新数据，并避免了不一致性问题。如果Redis发生故障，则可以从数据库中检索最新数据。 这种方案可以确保缓存数据与数据库数据的一致性。但是，在高并发情况下，由于需要频繁地访问数据库，可能会影响系统的性能。使用读写锁减少对数据库的访问，读写锁可以确保多个应用程序同时访问同一个数据时，只有一个应用程序可以更新数据。这可以减少并发更新引起的问题，并减少数据库负载。 2.3. 先更新数据库，延迟更新缓存（最终一致性方案）当数据发生变化时，先更新数据库，针对缓存的更新可以采用Canal组件来监听MySQL的binlog日志或者基于RocketMQ的可靠性消息通信来实现最终一致性 3. 总结Redis和数据库的缓存一致性问题是一个常见的挑战。为了确保缓存数据与数据库数据的一致性，我们可以采用以上三种解决方案。 在实际应用中，我们需要根据具体情况选择最适合自己的方案。同时，在使用Redis缓存数据时，我们需要注意缓存数据与数据库数据的一致性，并且需要对系统进行充分测试以确保系统稳定性。","tags":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/tags/Redis/"}]},{"title":"@Lombok注解常见的一些坑点","date":"2023-05-18T03:06:14.000Z","path":"2023/05/18/@Lombok注解常见的一些坑点/","text":"Lombok 是一个 Java 库，可以通过注解的方式来简化 Java 代码的编写。虽然 Lombok 的使用可以减少代码量，并提高代码的可读性和可维护性，但是在使用的时候还是需要注意一些坑点。 以下是一些常见的 Lombok 使用坑点： @Data 注解可能会导致无限递归。@Data 注解会自动生成 getter、setter、toString、equals、hashCode 方法，如果在类中包含了自己的实例变量，那么就会导致无限递归。因此，在使用 @Data 注解时需要注意这个问题，可以使用其他注解来代替。 @Builder 注解需要注意链式调用的顺序。@Builder 注解可以用于创建复杂对象，使用链式调用的方式设置属性。但是需要注意的是，设置属性的顺序需要与构造函数的参数顺序一致，否则会导致属性设置错误。 @AllArgsConstructor 和 @RequiredArgsConstructor 注解可能会导致构造函数参数过多。@AllArgsConstructor 注解会生成一个包含所有实例变量的构造函数，而 @RequiredArgsConstructor 注解则会生成一个包含必需实例变量的构造函数。这两个注解都可能会导致构造函数参数过多的问题，需要根据实际情况进行选择。 @Synchronized 注解可能会导致性能问题。@Synchronized 注解可以用于对方法进行同步，但是会导致性能问题。因此在使用 @Synchronized 注解时需要注意控制同步的范围，避免出现性能问题。 IDEA 等 IDE 工具可能无法正确识别 Lombok 注解。虽然 Lombok 支持大多数主流的 IDE 工具，但是有时候会出现 IDE 工具无法正确识别 Lombok 注解的情况。如果遇到这种情况，可以尝试更新 IDE 工具的插件或者升级 Lombok 的版本。 以上是一些常见的 Lombok 使用坑点，需要在使用 Lombok 时注意。 1. @Data 注解导致无限递归的案例@Data public class User { private Long id; private String username; private String password; private List&lt;Role&gt; roles; public User() { this.roles = new ArrayList&lt;&gt;(); } } @Data public class Role { private Long id; private String roleName; private List&lt;User&gt; users; public Role() { this.users = new ArrayList&lt;&gt;(); } } public class AppTest extends TestCase { public void testUserAndRole() { User user1 = new User(); user1.setId(1L); user1.setUsername(&quot;user1&quot;); user1.setPassword(&quot;password1&quot;); User user2 = new User(); user2.setId(2L); user2.setUsername(&quot;user2&quot;); user2.setPassword(&quot;password2&quot;); Role role1 = new Role(); role1.setId(1L); role1.setRoleName(&quot;role1&quot;); Role role2 = new Role(); role2.setId(2L); role2.setRoleName(&quot;role2&quot;); user1.getRoles().add(role1); user1.getRoles().add(role2); user2.getRoles().add(role2); role2.getUsers().add(user1); role2.getUsers().add(user1); role2.getUsers().add(user2); System.out.println(user1.toString()); System.out.println(role1.toString()); } } 上面的代码中，User 类和 Role 类之间是多对多的关系，都包含了对方的实例变量。这样在使用 @Data 注解时，会导致无限递归，从而导致 StackOverflowError 错误。 java.lang.StackOverflowError at java.base/java.lang.String.valueOf(String.java:2951) at com.ria.bean.Role.toString(Role.java:8) at java.base/java.lang.String.valueOf(String.java:2951) at java.base/java.lang.StringBuilder.append(StringBuilder.java:168) at java.base/java.util.AbstractCollection.toString(AbstractCollection.java:473) at java.base/java.lang.String.valueOf(String.java:2951) at com.ria.bean.User.toString(User.java:8) 解决方法： 可以使用 @ToString、@EqualsAndHashCode、@Getter、@Setter、@RequiredArgsConstructor 注解来代替 @Data 注解，分别生成 toString、equals、hashCode、getter、setter、构造函数等方法。 2.@Builder 注解链式调用顺序错误的案例：@Builder public class User { private Long id; private String username; private String password; private Integer age; } User user = User.builder() .username(&quot;test&quot;) .age(20) .id(1L) .build(); 上面的代码中，使用 @Builder 注解创建 User 对象时，设置属性的顺序与构造函数的参数顺序不一致，导致创建 User 对象时属性设置错误。 解决方法： 需要保证设置属性的顺序与构造函数的参数顺序一致，可以使用 @Builder.Default 注解为属性设置默认值来解决这个问题。 @AllArgsConstructor 和 @RequiredArgsConstructor 注解导致构造函数参数过多的案例： @AllArgsConstructor public class User { private Long id; private String username; private String password; private String email; private String phone; private String address; private Integer age; // 省略 getter、setter 方法 } User user = new User(1L, &quot;test&quot;, &quot;123456&quot;, &quot;test@test.com&quot;, &quot;123456789&quot;, &quot;北京市&quot;, 20); 上面的代码中，使用 @AllArgsConstructor 注解为 User 类生成了一个包含所有实例变量的构造函数，导致构造函数参数过多，不便于使用。 解决方法： 可以使用 @NoArgsConstructor、@NonNull、@Builder 等注解来代替 @AllArgsConstructor 注解，根据实际情况选择合适的注解。 @Synchronized 注解导致性能问题的案例： @Data public class User { private Long id; private String username; private String password; private String email; private String phone; private String address; private Integer age; @Synchronized public void updateUser(User user) { // 更新用户信息 } } 上面的代码中，使用 @Synchronized 注解对 updateUser 方法进行同步，但是这会导致性能问题。 解决方法： 可以通过其他方式来控制同步的范围，如使用 synchronized 关键字或者使用 Lock 接口等。","tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]}],"categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/tags/Redis/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]}