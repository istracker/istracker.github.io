{"pages":[{},{}],"posts":[{"title":"@Lombok注解常见的一些坑点","date":"2023-05-18T03:06:14.000Z","path":"2023/05/18/@Lombok注解常见的一些坑点/","text":"Lombok 是一个 Java 库，可以通过注解的方式来简化 Java 代码的编写。虽然 Lombok 的使用可以减少代码量，并提高代码的可读性和可维护性，但是在使用的时候还是需要注意一些坑点。 以下是一些常见的 Lombok 使用坑点： @Data 注解可能会导致无限递归。@Data 注解会自动生成 getter、setter、toString、equals、hashCode 方法，如果在类中包含了自己的实例变量，那么就会导致无限递归。因此，在使用 @Data 注解时需要注意这个问题，可以使用其他注解来代替。 @Builder 注解需要注意链式调用的顺序。@Builder 注解可以用于创建复杂对象，使用链式调用的方式设置属性。但是需要注意的是，设置属性的顺序需要与构造函数的参数顺序一致，否则会导致属性设置错误。 @AllArgsConstructor 和 @RequiredArgsConstructor 注解可能会导致构造函数参数过多。@AllArgsConstructor 注解会生成一个包含所有实例变量的构造函数，而 @RequiredArgsConstructor 注解则会生成一个包含必需实例变量的构造函数。这两个注解都可能会导致构造函数参数过多的问题，需要根据实际情况进行选择。 @Synchronized 注解可能会导致性能问题。@Synchronized 注解可以用于对方法进行同步，但是会导致性能问题。因此在使用 @Synchronized 注解时需要注意控制同步的范围，避免出现性能问题。 IDEA 等 IDE 工具可能无法正确识别 Lombok 注解。虽然 Lombok 支持大多数主流的 IDE 工具，但是有时候会出现 IDE 工具无法正确识别 Lombok 注解的情况。如果遇到这种情况，可以尝试更新 IDE 工具的插件或者升级 Lombok 的版本。 以上是一些常见的 Lombok 使用坑点，需要在使用 Lombok 时注意。 @Data 注解导致无限递归的案例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@Datapublic class User &#123; private Long id; private String username; private String password; private List&lt;Role&gt; roles; public User() &#123; this.roles = new ArrayList&lt;&gt;(); &#125; &#125;@Datapublic class Role &#123; private Long id; private String roleName; private List&lt;User&gt; users; public Role() &#123; this.users = new ArrayList&lt;&gt;(); &#125;&#125;public class AppTest extends TestCase &#123; public void testUserAndRole() &#123; User user1 = new User(); user1.setId(1L); user1.setUsername(&quot;user1&quot;); user1.setPassword(&quot;password1&quot;); User user2 = new User(); user2.setId(2L); user2.setUsername(&quot;user2&quot;); user2.setPassword(&quot;password2&quot;); Role role1 = new Role(); role1.setId(1L); role1.setRoleName(&quot;role1&quot;); Role role2 = new Role(); role2.setId(2L); role2.setRoleName(&quot;role2&quot;); user1.getRoles().add(role1); user1.getRoles().add(role2); user2.getRoles().add(role2); role2.getUsers().add(user1); role2.getUsers().add(user1); role2.getUsers().add(user2); System.out.println(user1.toString()); System.out.println(role1.toString()); &#125;&#125; 上面的代码中，User 类和 Role 类之间是多对多的关系，都包含了对方的实例变量。这样在使用 @Data 注解时，会导致无限递归，从而导致 StackOverflowError 错误。 解决方法： 可以使用 @ToString、@EqualsAndHashCode、@Getter、@Setter、@RequiredArgsConstructor 注解来代替 @Data 注解，分别生成 toString、equals、hashCode、getter、setter、构造函数等方法。 @Builder 注解链式调用顺序错误的案例： 1234567891011121314@Builderpublic class User &#123; private Long id; private String username; private String password; private Integer age;&#125;User user = User.builder() .username(&quot;test&quot;) .age(20) .id(1L) .build(); 上面的代码中，使用 @Builder 注解创建 User 对象时，设置属性的顺序与构造函数的参数顺序不一致，导致创建 User 对象时属性设置错误。 解决方法： 需要保证设置属性的顺序与构造函数的参数顺序一致，可以使用 @Builder.Default 注解为属性设置默认值来解决这个问题。 @AllArgsConstructor 和 @RequiredArgsConstructor 注解导致构造函数参数过多的案例： 1234567891011121314@AllArgsConstructorpublic class User &#123; private Long id; private String username; private String password; private String email; private String phone; private String address; private Integer age; // 省略 getter、setter 方法&#125;User user = new User(1L, &quot;test&quot;, &quot;123456&quot;, &quot;test@test.com&quot;, &quot;123456789&quot;, &quot;北京市&quot;, 20); 上面的代码中，使用 @AllArgsConstructor 注解为 User 类生成了一个包含所有实例变量的构造函数，导致构造函数参数过多，不便于使用。 解决方法： 可以使用 @NoArgsConstructor、@NonNull、@Builder 等注解来代替 @AllArgsConstructor 注解，根据实际情况选择合适的注解。 @Synchronized 注解导致性能问题的案例： 12345678910111213141516@Datapublic class User &#123; private Long id; private String username; private String password; private String email; private String phone; private String address; private Integer age; @Synchronized public void updateUser(User user) &#123; // 更新用户信息 &#125;&#125; 上面的代码中，使用 @Synchronized 注解对 updateUser 方法进行同步，但是这会导致性能问题。 解决方法： 可以通过其他方式来控制同步的范围，如使用 synchronized 关键字或者使用 Lock 接口等。","tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]}],"categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]}